# Nate's Awesome List

![Awesome](https://awesome.re/badge.svg)

My own personal [awesome list](https://github.com/sindresorhus/awesome/blob/main/awesome.md) in a variety of topics.

# Software Engineering

  * [A Few Thoughts About Path Coverage](https://blog.regehr.org/archives/386)
    * Some interesting thoughts on what it means for a code-base to really be thoroughly unit-tested.
    
  * [3 tribes of programming](https://josephg.com/blog/3-tribes/)
    * Incredibly elucidating analysis of the cultural divides within the software engineering community. Also, explains why I really like Rust. :)
    
  * [Sum Types are Not a Silver Bullet](https://sintrastes.github.io/blog/posts/2021-07-19-sum_types_are_not_a_silver_bullet.html)
    * This is something I wrote -- but I think it's an incredibly important lesson when trying to architect applications and systems in a functional style.

  * [Abstraction: Not What You Think It Is](https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html)
    * People in the software engineering community (especially in the context of object-oriented programming) often talk about code as being "too abstract" -- but is that really the issue? This post gives a fascinating analysis of the different things that people mean when they talk about "abstraction" in software engineering, and forces you to define your terms (and maybe ask others to define their ters) for clearer discussions. 
    
  * [No-code, no thought Substrates for simple programming for all](http://tomasp.net/blog/2022/no-code-substrates/)
    * An interesting take on the "no/low code revolution" that will inspire you to think of ways to make your application more flexible and your capabilities for customization more discoverable -- or at least that's what I got out of it.
    
  * [The future of software, the end of apps, and why UX designers should care about type theory](https://pchiusano.github.io/2013-05-22/future-of-software.html)
    * Applications of type theory? Democratization of software development? Making it easier to glue together functionality without a lot of boilerplate, rather than sandboxing everything into black-box "apps"? Yeah -- safe to say this hits a lot of "awesome" points in my book. Also, I feel like this is very similar in theme to the above post by Petricek.
    
# Research (Or just cool) Languages

  * [Koka](https://koka-lang.github.io/koka/doc/index.html)
    * Really innovative optimization (reuse analysis) that in many cases can convert functional style code to runtime-less C that mutates in place.

  * [MarkovJunior](https://github.com/mxgmn/MarkovJunior)
    * A language that somehow combines the work of Andrey Markov Jr. (think the Russian School of constructive mathematics), and (by way of a probabalistic interpretation of Markov Algorithms) Andrey Markov Sr. (Think Markov Networks, Hidden Markov Models). This is unbelievably <s>nerdy</s> cool. Also, look at those example gifs! If I don't use this some day (or something similar) for procedural generation of game worlds, I'll be dissapointed in myself.

  * [Refal](https://en.wikipedia.org/wiki/Refal)
    * A language nearly as old as Fortran and Lisp, built on a completely different paradigm (Markov Algorithms) than anything I've ever seen. Why does no one talk about this? 

# Haskell

  * [Learn You a Haskell For Great Good](http://learnyouahaskell.com/)
    * Maybe somewhat outdated, but a very good and gentle introduction to the language. Also, it's free to read online, so you have no excuse!

# Kotlin

# Rust
